package com.friend.spider.lnn.bingfa.chapter01;/** * 1.2死锁 * 以下代码会引起死锁，线程T1和T2互相等待对方释放锁 * 出现死锁要通过dump线程查看 * * 输出结果为2 * * 以下知识点有待深究？？ * 避免一个线程同时获取多个锁 * 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源 * 尝试使用定时锁，使用lock.tryLook(timeout)来替代使用内部锁机制 * 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况 */public class DeadLockDemo {    private static String A = "A";    private static String B = "B";    public static void main(String[] args) {        new DeadLockDemo().deadLock();    }    private void deadLock() {        Thread t1 = new Thread(){            @Override            public void run(){                synchronized (A){                    try {                        Thread.currentThread().sleep(2000);                    } catch (Exception e) {                        System.out.println("1");                    }                }            }        };        Thread t2 = new Thread(){            @Override            public void run(){                synchronized (B){                    synchronized (A){                        System.out.println("2");                    }                }            }        };        t1.start();        t2.start();    }}